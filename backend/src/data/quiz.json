[
  { "id": "q1",  "category": "sorting",  "question": "What is the average time complexity of Quick Sort?", "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], "answerIndex": 1, "explanation": "Quick Sort partitions the array and recurses on halves, giving O(n log n) average." },
  { "id": "q2",  "category": "sorting",  "question": "Which sorting algorithm is stable by design?", "options": ["Quick Sort", "Heap Sort", "Merge Sort", "Selection Sort"], "answerIndex": 2, "explanation": "Merge Sort preserves the order of equal elements (stable)." },
  { "id": "q3",  "category": "sorting",  "question": "Insertion Sort performs best on which kind of input?", "options": ["Reverse-sorted", "Random", "Nearly-sorted", "All equal"], "answerIndex": 2, "explanation": "Insertion Sort is efficient on nearly-sorted arrays." },
  { "id": "q7",  "category": "sorting",  "question": "Worst-case of Quick Sort?", "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], "answerIndex": 2, "explanation": "Poor pivots degrade Quick Sort to O(n^2)." },
  { "id": "q8",  "category": "sorting",  "question": "Space complexity of Merge Sort?", "options": ["O(1)", "O(log n)", "O(n)", "O(n^2)"], "answerIndex": 2, "explanation": "Merge Sort needs auxiliary arrays." },
  { "id": "q9",  "category": "sorting",  "question": "Which is in-place?", "options": ["Merge Sort", "Quick Sort", "Counting Sort", "Radix Sort"], "answerIndex": 1, "explanation": "Quick Sort is in-place (typical implementation)." },
  { "id": "q10", "category": "sorting",  "question": "Average time of Insertion Sort?", "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], "answerIndex": 2, "explanation": "Insertion Sort averages O(n^2)." },
  { "id": "q11", "category": "sorting",  "question": "Counting Sort works best when?", "options": ["Keys small range", "Data random", "Array reversed", "All unique"], "answerIndex": 0, "explanation": "Counting Sort is linear when key range is small." },
  { "id": "q12", "category": "sorting",  "question": "Which is stable?", "options": ["Quick Sort", "Selection Sort", "Merge Sort", "Heap Sort"], "answerIndex": 2, "explanation": "Merge Sort is stable; Selection/Heap are not." },
  { "id": "q13", "category": "sorting",  "question": "Heapsort time complexity?", "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], "answerIndex": 1, "explanation": "Heapsort runs in O(n log n)." },
  { "id": "q14", "category": "sorting",  "question": "Best case of Bubble Sort?", "options": ["O(n)", "O(n log n)", "O(n^2)", "O(1)"], "answerIndex": 0, "explanation": "With early exit optimization, Bubble Sort best-case is O(n)." },
  { "id": "q15", "category": "sorting",  "question": "Which algorithm divides and conquers around a pivot?", "options": ["Merge Sort", "Quick Sort", "Insertion Sort", "Selection Sort"], "answerIndex": 1, "explanation": "Quick Sort chooses a pivot and partitions." },
  { "id": "q16", "category": "sorting",  "question": "Stable linear-time sort for integers?", "options": ["Counting Sort", "Quick Sort", "Heap Sort", "Shell Sort"], "answerIndex": 0, "explanation": "Counting Sort is linear and stable for small key ranges." },
  { "id": "q17", "category": "sorting",  "question": "Shell Sort worst-case is typically?", "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], "answerIndex": 2, "explanation": "Depends on gaps, often O(n^2)." },
  { "id": "q18", "category": "sorting",  "question": "Which keeps partial array sorted as it grows?", "options": ["Insertion Sort", "Merge Sort", "Heap Sort", "Radix Sort"], "answerIndex": 0, "explanation": "Insertion Sort grows a sorted prefix." },

  { "id": "q4",  "category": "searching", "question": "Binary Search requires which precondition?", "options": ["Distinct elements", "Sorted array", "Balanced tree", "No duplicates"], "answerIndex": 1, "explanation": "Binary Search assumes sorted input." },
  { "id": "q5",  "category": "searching", "question": "Average time complexity of Linear Search is?", "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"], "answerIndex": 2, "explanation": "Linear Search averages O(n)." },
  { "id": "s1",  "category": "searching", "question": "Binary Search time complexity?", "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"], "answerIndex": 1, "explanation": "Halves the search space." },
  { "id": "s2",  "category": "searching", "question": "Prerequisite for Interpolation Search?", "options": ["Uniformly distributed keys", "Reversed array", "Unique values", "Small n"], "answerIndex": 0, "explanation": "Works well on uniformly distributed sorted data." },
  { "id": "s3",  "category": "searching", "question": "Exponential Search is useful for?", "options": ["Unbounded size arrays", "Hash tables", "Trees", "Linked lists"], "answerIndex": 0, "explanation": "Finds range then binary searches." },
  { "id": "s4",  "category": "searching", "question": "On unsorted arrays without preprocessing, best choice is?", "options": ["Binary Search", "Linear Search", "Jump Search", "Fibonacci Search"], "answerIndex": 1, "explanation": "Only linear scan works without preprocessing." },
  { "id": "s5",  "category": "searching", "question": "Jump Search step size is about?", "options": ["1", "log n", "sqrt(n)", "n"], "answerIndex": 2, "explanation": "Optimal jump is about sqrt(n)." },
  { "id": "s6",  "category": "searching", "question": "Hash table average search time?", "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"], "answerIndex": 0, "explanation": "With good hashing, expected O(1)." },
  { "id": "s7",  "category": "searching", "question": "Binary Search on linked lists is inefficient because?", "options": ["No random access", "Extra memory", "Duplicates fail", "Requires recursion"], "answerIndex": 0, "explanation": "Midpoint access is O(n)." },
  { "id": "s8",  "category": "searching", "question": "Fibonacci Search is similar to?", "options": ["Jump Search", "Binary Search", "Interpolation Search", "DFS"], "answerIndex": 1, "explanation": "It splits ranges like binary using Fibonacci numbers." },
  { "id": "s9",  "category": "searching", "question": "When array is very large and on disk, prefer?", "options": ["Linear Search", "Binary Search", "Ternary Search", "Interpolation"], "answerIndex": 1, "explanation": "Minimizes probes by halving range each time." },
  { "id": "s10", "category": "searching", "question": "Ternary Search is effective on?", "options": ["Sorted arrays", "Unimodal functions", "Hash tables", "Trees"], "answerIndex": 1, "explanation": "Used to find extrema in unimodal functions." },
  { "id": "s11", "category": "searching", "question": "Lower bound finds?", "options": ["First element", "First >= key", "Last <= key", "Exact match"], "answerIndex": 1, "explanation": "Lower bound returns first element not less than key." },
  { "id": "s12", "category": "searching", "question": "Upper bound finds?", "options": ["First element", "First > key", "Last <= key", "Exact match"], "answerIndex": 1, "explanation": "Upper bound returns first element greater than key." },
  { "id": "s13", "category": "searching", "question": "Binary Search tree search complexity (average)?", "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"], "answerIndex": 1, "explanation": "Balanced BST provides O(log n)." },
  { "id": "s14", "category": "searching", "question": "Which fails if array not sorted?", "options": ["Linear", "Binary", "Jump", "Fibonacci"], "answerIndex": 1, "explanation": "Binary-like methods assume sorted order." },
  { "id": "s15", "category": "searching", "question": "What does our visualization show when key absent?", "options": ["Keeps searching forever", "Highlights all as not found", "Crashes", "Returns random index"], "answerIndex": 1, "explanation": "Non-matching indices are marked notfound and message shown." },

  { "id": "q6",  "category": "general",  "question": "Which algorithm has the best worst-case time complexity?", "options": ["Quick Sort", "Merge Sort", "Insertion Sort", "Selection Sort"], "answerIndex": 1, "explanation": "Merge Sort guarantees O(n log n) in the worst-case." }
]


